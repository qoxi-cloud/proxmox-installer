name: CD

on:
  workflow_run:
    workflows: ["CI"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      run_id:
        description: 'CI workflow run ID to deploy'
        required: true
        type: string

jobs:
  prepareAndWait:
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' &&
       github.event.workflow_run.pull_requests[0] != null)
    permissions:
      checks: read
      pull-requests: read
      actions: read
    outputs:
      run_id: ${{ steps.setup.outputs.run_id }}
      pr_number: ${{ steps.setup.outputs.pr_number }}
    steps:
      - name: Setup run parameters
        id: setup
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "run_id=${{ inputs.run_id }}" >> $GITHUB_OUTPUT
            echo "pr_number=" >> $GITHUB_OUTPUT
          else
            echo "run_id=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
            echo "pr_number=${{ github.event.workflow_run.pull_requests[0].number }}" >> $GITHUB_OUTPUT
          fi

  waitForCi:
    needs: prepareAndWait
    if: needs.prepareAndWait.outputs.pr_number != ''
    uses: ./.github/workflows/waitForChecks.yml
    with:
      check_type: pr
      pr_number: ${{ needs.prepareAndWait.outputs.pr_number }}
      max_attempts: 60
      delay_ms: 10000

  deployPr:
    runs-on: ubuntu-latest
    needs: [prepareAndWait, waitForCi]
    if: always() && needs.prepareAndWait.result == 'success' && (needs.waitForCi.result == 'success' || needs.waitForCi.result == 'skipped')

    permissions:
      contents: write
      pull-requests: write
      actions: read
      repository-projects: read

    steps:
      - name: Download PR metadata
        uses: actions/download-artifact@v4
        with:
          name: pr-metadata
          path: /tmp/pr-metadata
          run-id: ${{ needs.prepareAndWait.outputs.run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: pve-install
          path: /tmp/build
          run-id: ${{ needs.prepareAndWait.outputs.run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Read PR metadata
        id: pr
        run: |
          PR_NUMBER=$(cat /tmp/pr-metadata/pr_number)
          PR_BRANCH=$(cat /tmp/pr-metadata/pr_branch)
          PR_REPO=$(cat /tmp/pr-metadata/pr_repo)
          VERSION=$(grep '^VERSION=' /tmp/build/pve-install.min.sh | head -1 | sed 's/VERSION="//;s/"//')

          echo "number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          echo "branch=${PR_BRANCH}" >> $GITHUB_OUTPUT
          echo "repo=${PR_REPO}" >> $GITHUB_OUTPUT
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "filename=pve-install-pr.${PR_NUMBER}.min.sh" >> $GITHUB_OUTPUT

          # Check if this is a fork PR
          if [[ "$PR_REPO" != "${{ github.repository }}" ]]; then
            echo "is_fork=true" >> $GITHUB_OUTPUT
          else
            echo "is_fork=false" >> $GITHUB_OUTPUT
          fi

      - name: Checkout gh-pages
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          fetch-depth: 0

      - name: Deploy PR script
        run: |
          FILENAME="${{ steps.pr.outputs.filename }}"

          # Copy minified PR script with unique name
          cp /tmp/build/pve-install.min.sh "${FILENAME}"

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Add and commit
          git add "${FILENAME}"
          git commit -m "Deploy PR #${{ steps.pr.outputs.number }} test script" || echo "No changes to commit"
          git push origin gh-pages

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.pr.outputs.number }};
            const version = '${{ steps.pr.outputs.version }}';
            const filename = '${{ steps.pr.outputs.filename }}';
            const prBranch = '${{ steps.pr.outputs.branch }}';
            const prRepo = '${{ steps.pr.outputs.repo }}';
            const isFork = ${{ steps.pr.outputs.is_fork }};
            const repoOwner = context.repo.owner;
            const repoName = context.repo.repo;
            const scriptUrl = `https://${repoOwner}.github.io/${repoName}/${filename}`;

            const forkNote = isFork
              ? `\n\nüç¥ **Fork PR:** Templates will be loaded from [\`${prRepo}\`](https://github.com/${prRepo}/tree/${prBranch}).`
              : '';

            const tableRows = [
              '| Property | Value |',
              '|----------|-------|',
              `| **Version** | \`${version}\` |`,
              `| **Branch** | \`${prBranch}\` |`,
              `| **Source** | ${isFork ? `Fork: \`${prRepo}\`` : 'Same repo'} |`
            ].join('\n');

            const body = `## üß™ Test Build Available

            ${tableRows}

            ### Quick Install (for testing)

            \`\`\`bash
            bash <(curl -sSL ${scriptUrl})
            \`\`\`

            ### Direct Link

            üì• [${filename}](${scriptUrl})

            ---
            ‚ö†Ô∏è **Note:** This is a test build. Templates will be loaded from the \`${prBranch}\` branch.${forkNote}

            ü§ñ *This comment is automatically updated on each push to this PR.*`.replace(/^ +/gm, '');

            // Find and delete existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('üß™ Test Build Available')
            );

            if (botComment) {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id
              });
            }

            // Create new comment at the end
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: body
            });
