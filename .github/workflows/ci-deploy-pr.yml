name: CI / Deploy PR

# This workflow runs in the context of the base repository,
# allowing it to deploy PR builds from forks securely.
# It triggers after the build workflow completes.

on:
  workflow_run:
    workflows: ["CI / Build"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      run_id:
        description: 'CI workflow run ID to deploy'
        required: true
        type: string

jobs:
  run:
    runs-on: ubuntu-latest
    # Run on workflow_run from PR (push events to PR branches), or on manual dispatch
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' &&
       github.event.workflow_run.pull_requests[0] != null)

    permissions:
      contents: write
      pull-requests: write
      actions: read

    steps:
      - name: Set run ID
        id: run
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "id=${{ inputs.run_id }}" >> $GITHUB_OUTPUT
          else
            echo "id=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
          fi

      - name: Download PR metadata
        uses: actions/download-artifact@v4
        with:
          name: pr-metadata
          path: /tmp/pr-metadata
          run-id: ${{ steps.run.outputs.id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: pve-install
          path: /tmp/build
          run-id: ${{ steps.run.outputs.id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Read PR metadata
        id: pr
        run: |
          PR_NUMBER=$(cat /tmp/pr-metadata/pr_number)
          PR_BRANCH=$(cat /tmp/pr-metadata/pr_branch)
          PR_REPO=$(cat /tmp/pr-metadata/pr_repo)
          VERSION=$(grep '^VERSION=' /tmp/build/pve-install.min.sh | head -1 | sed 's/VERSION="//;s/"//')

          echo "number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          echo "branch=${PR_BRANCH}" >> $GITHUB_OUTPUT
          echo "repo=${PR_REPO}" >> $GITHUB_OUTPUT
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "filename=pve-install-pr.${PR_NUMBER}.min.sh" >> $GITHUB_OUTPUT

          # Check if this is a fork PR
          if [[ "$PR_REPO" != "${{ github.repository }}" ]]; then
            echo "is_fork=true" >> $GITHUB_OUTPUT
          else
            echo "is_fork=false" >> $GITHUB_OUTPUT
          fi

      - name: Checkout gh-pages
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          fetch-depth: 0

      - name: Deploy PR script
        run: |
          FILENAME="${{ steps.pr.outputs.filename }}"

          # Copy minified PR script with unique name
          cp /tmp/build/pve-install.min.sh "${FILENAME}"

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Add and commit
          git add "${FILENAME}"
          git commit -m "Deploy PR #${{ steps.pr.outputs.number }} test script" || echo "No changes to commit"
          git push origin gh-pages

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.pr.outputs.number }};
            const version = '${{ steps.pr.outputs.version }}';
            const filename = '${{ steps.pr.outputs.filename }}';
            const prBranch = '${{ steps.pr.outputs.branch }}';
            const prRepo = '${{ steps.pr.outputs.repo }}';
            const isFork = ${{ steps.pr.outputs.is_fork }};
            const repoOwner = context.repo.owner;
            const repoName = context.repo.repo;
            const scriptUrl = `https://${repoOwner}.github.io/${repoName}/${filename}`;

            const forkNote = isFork
              ? `\n\nüç¥ **Fork PR:** Templates will be loaded from [\`${prRepo}\`](https://github.com/${prRepo}/tree/${prBranch}).`
              : '';

            const tableRows = [
              '| Property | Value |',
              '|----------|-------|',
              `| **Version** | \`${version}\` |`,
              `| **Branch** | \`${prBranch}\` |`,
              `| **Source** | ${isFork ? `Fork: \`${prRepo}\`` : 'Same repo'} |`
            ].join('\n');

            const body = `## üß™ Test Build Available

            ${tableRows}

            ### Quick Install (for testing)

            \`\`\`bash
            bash <(curl -sSL ${scriptUrl})
            \`\`\`

            ### Direct Link

            üì• [${filename}](${scriptUrl})

            ---
            ‚ö†Ô∏è **Note:** This is a test build. Templates will be loaded from the \`${prBranch}\` branch.${forkNote}

            ü§ñ *This comment is automatically updated on each push to this PR.*`.replace(/^ +/gm, '');

            // Find and delete existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('üß™ Test Build Available')
            );

            if (botComment) {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id
              });
            }

            // Create new comment at the end
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: body
            });
