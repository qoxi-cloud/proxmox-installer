name: deploy-pr

on:
  workflow_run:
    workflows: ["build"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      run_id:
        description: 'build workflow run ID to deploy'
        required: true
        type: string

jobs:
  prepare-and-wait:
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' &&
       github.event.workflow_run.pull_requests[0] != null)
    permissions:
      checks: read
      pull-requests: read
      actions: read
    outputs:
      run_id: ${{ steps.setup.outputs.run_id }}
      pr_number: ${{ steps.setup.outputs.pr_number }}
    steps:
      - name: Setup run parameters
        id: setup
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "run_id=${{ inputs.run_id }}" >> $GITHUB_OUTPUT
            echo "pr_number=" >> $GITHUB_OUTPUT
          else
            echo "run_id=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
            echo "pr_number=${{ github.event.workflow_run.pull_requests[0].number }}" >> $GITHUB_OUTPUT
          fi

  wait-for-ci:
    needs: prepare-and-wait
    if: needs.prepare-and-wait.outputs.pr_number != ''
    uses: ./.github/workflows/wait-for-checks.yml
    permissions:
      checks: read
      pull-requests: read
      actions: read
    with:
      check_type: pr
      pr_number: ${{ needs.prepare-and-wait.outputs.pr_number }}
      max_attempts: 60
      delay_ms: 10000

  deploy-pr:
    runs-on: ubuntu-latest
    needs: [prepare-and-wait, wait-for-ci]
    if: always() && needs.prepare-and-wait.result == 'success' && (needs.wait-for-ci.result == 'success' || needs.wait-for-ci.result == 'skipped')

    permissions:
      contents: write
      pull-requests: write
      actions: read
      repository-projects: read
      deployments: write

    steps:
      - name: Download PR metadata
        uses: actions/download-artifact@v4
        with:
          name: pr-metadata
          path: /tmp/pr-metadata
          run-id: ${{ needs.prepare-and-wait.outputs.run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: pve-install
          path: /tmp/build
          run-id: ${{ needs.prepare-and-wait.outputs.run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Read PR metadata
        id: pr
        run: |
          PR_NUMBER=$(cat /tmp/pr-metadata/pr_number)
          PR_BRANCH=$(cat /tmp/pr-metadata/pr_branch)
          PR_REPO=$(cat /tmp/pr-metadata/pr_repo)
          VERSION=$(grep 'readonly VERSION=' /tmp/build/pve-install.min.sh | head -1 | sed 's/.*VERSION="//;s/"//')

          echo "number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          echo "branch=${PR_BRANCH}" >> $GITHUB_OUTPUT
          echo "repo=${PR_REPO}" >> $GITHUB_OUTPUT
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "filename=pve-install-pr.${PR_NUMBER}.min.sh" >> $GITHUB_OUTPUT

          # Check if this is a fork PR
          if [[ "$PR_REPO" != "${{ github.repository }}" ]]; then
            echo "is_fork=true" >> $GITHUB_OUTPUT
          else
            echo "is_fork=false" >> $GITHUB_OUTPUT
          fi

      - name: Create deployment
        id: deployment
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.pr.outputs.number }};
            const prBranch = '${{ steps.pr.outputs.branch }}';
            const version = '${{ steps.pr.outputs.version }}';
            const repoOwner = context.repo.owner;
            const repoName = context.repo.repo;

            // Create deployment
            const { data: deployment } = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: prBranch,
              environment: `pr-${prNumber}`,
              description: `Deploy PR #${prNumber} (${version})`,
              auto_merge: false,
              required_contexts: []
            });

            core.setOutput('deployment_id', deployment.id);
            return deployment.id;

      - name: Checkout gh-pages
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          fetch-depth: 0

      - name: Deploy PR script
        run: |
          FILENAME="${{ steps.pr.outputs.filename }}"

          # Copy minified PR script with unique name
          cp /tmp/build/pve-install.min.sh "${FILENAME}"

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Add and commit
          git add "${FILENAME}"
          git commit -m "Deploy PR #${{ steps.pr.outputs.number }} test script" || echo "No changes to commit"
          git push origin gh-pages

      - name: Wait for deployment to be available
        run: |
          SCRIPT_URL="https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/${{ steps.pr.outputs.filename }}"

          echo "Waiting for ${SCRIPT_URL} to be available..."

          MAX_ATTEMPTS=90
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            if curl -sSf -o /dev/null "${SCRIPT_URL}"; then
              echo "‚úì Script is available"
              exit 0
            fi

            ATTEMPT=$((ATTEMPT + 1))
            echo "Attempt ${ATTEMPT}/${MAX_ATTEMPTS} - waiting 2s..."
            sleep 2
          done

          echo "::warning::Script not available after ${MAX_ATTEMPTS} attempts, proceeding anyway"

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.pr.outputs.number }};
            const version = '${{ steps.pr.outputs.version }}';
            const filename = '${{ steps.pr.outputs.filename }}';
            const prBranch = '${{ steps.pr.outputs.branch }}';
            const prRepo = '${{ steps.pr.outputs.repo }}';
            const isFork = ${{ steps.pr.outputs.is_fork }};
            const repoOwner = context.repo.owner;
            const repoName = context.repo.repo;
            const scriptUrl = `https://${repoOwner}.github.io/${repoName}/${filename}`;

            const forkNote = isFork
              ? `\n\nüç¥ **Fork PR:** Templates will be loaded from [\`${prRepo}\`](https://github.com/${prRepo}/tree/${prBranch}).`
              : '';

            const tableRows = [
              '| Property | Value |',
              '|----------|-------|',
              `| **Version** | \`${version}\` |`,
              `| **Branch** | \`${prBranch}\` |`,
              `| **Source** | ${isFork ? `Fork: \`${prRepo}\`` : 'Same repo'} |`
            ].join('\n');

            const body = `## üß™ Test Build Available

            ${tableRows}

            ### Quick Install (for testing)

            \`\`\`bash
            bash <(curl -sSL ${scriptUrl})
            \`\`\`

            ### Direct Link

            üì• [${filename}](${scriptUrl})

            ---
            ‚ö†Ô∏è **Note:** This is a test build. Templates will be loaded from the \`${prBranch}\` branch.${forkNote}

            ü§ñ *This comment is automatically updated on each push to this PR.*`.replace(/^ +/gm, '');

            // Find and delete existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('üß™ Test Build Available')
            );

            if (botComment) {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id
              });
            }

            // Create new comment at the end
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: body
            });

      - name: Update deployment status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const deploymentId = ${{ steps.deployment.outputs.deployment_id }};
            const prNumber = ${{ steps.pr.outputs.number }};
            const filename = '${{ steps.pr.outputs.filename }}';
            const repoOwner = context.repo.owner;
            const repoName = context.repo.repo;
            const scriptUrl = `https://${repoOwner}.github.io/${repoName}/${filename}`;

            const state = '${{ job.status }}' === 'success' ? 'success' : 'failure';

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deploymentId,
              state: state,
              environment_url: scriptUrl,
              description: state === 'success'
                ? `Deployed to pr-${prNumber}`
                : 'Deployment failed',
              auto_inactive: false
            });
